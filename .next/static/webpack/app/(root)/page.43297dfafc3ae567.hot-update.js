"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(root)/page",{

/***/ "(app-pages-browser)/./lib/utils.ts":
/*!**********************!*\
  !*** ./lib/utils.ts ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   authFormSchema: function() { return /* binding */ authFormSchema; },\n/* harmony export */   calculateInterest: function() { return /* binding */ calculateInterest; },\n/* harmony export */   cn: function() { return /* binding */ cn; },\n/* harmony export */   convertNumberToMoney: function() { return /* binding */ convertNumberToMoney; },\n/* harmony export */   countTransactionCategories: function() { return /* binding */ countTransactionCategories; },\n/* harmony export */   decryptId: function() { return /* binding */ decryptId; },\n/* harmony export */   encryptId: function() { return /* binding */ encryptId; },\n/* harmony export */   extractCustomerIdFromUrl: function() { return /* binding */ extractCustomerIdFromUrl; },\n/* harmony export */   fetchMetalsPrices: function() { return /* binding */ fetchMetalsPrices; },\n/* harmony export */   formUrlQuery: function() { return /* binding */ formUrlQuery; },\n/* harmony export */   formatAmount: function() { return /* binding */ formatAmount; },\n/* harmony export */   formatDateTime: function() { return /* binding */ formatDateTime; },\n/* harmony export */   formatDateToDisplay: function() { return /* binding */ formatDateToDisplay; },\n/* harmony export */   getAccountTypeColors: function() { return /* binding */ getAccountTypeColors; },\n/* harmony export */   getTransactionStatus: function() { return /* binding */ getTransactionStatus; },\n/* harmony export */   parseStringify: function() { return /* binding */ parseStringify; },\n/* harmony export */   removeSpecialCharacters: function() { return /* binding */ removeSpecialCharacters; }\n/* harmony export */ });\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var query_string__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! query-string */ \"(app-pages-browser)/./node_modules/query-string/index.js\");\n/* harmony import */ var tailwind_merge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tailwind-merge */ \"(app-pages-browser)/./node_modules/tailwind-merge/dist/bundle-mjs.mjs\");\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zod */ \"(app-pages-browser)/./node_modules/zod/lib/index.mjs\");\n/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! moment */ \"(app-pages-browser)/./node_modules/moment/moment.js\");\n/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(moment__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/* eslint-disable no-prototype-builtins */ \n\n\n\n\n\nfunction cn() {\n    for(var _len = arguments.length, inputs = new Array(_len), _key = 0; _key < _len; _key++){\n        inputs[_key] = arguments[_key];\n    }\n    return (0,tailwind_merge__WEBPACK_IMPORTED_MODULE_2__.twMerge)((0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(inputs));\n}\n// FORMAT DATE TIME\nconst formatDateTime = (dateString)=>{\n    const dateTimeOptions = {\n        weekday: \"short\",\n        month: \"short\",\n        day: \"numeric\",\n        hour: \"numeric\",\n        minute: \"numeric\",\n        hour12: true\n    };\n    const dateDayOptions = {\n        weekday: \"short\",\n        year: \"numeric\",\n        month: \"2-digit\",\n        day: \"2-digit\"\n    };\n    const dateOptions = {\n        month: \"short\",\n        year: \"numeric\",\n        day: \"numeric\"\n    };\n    const timeOptions = {\n        hour: \"numeric\",\n        minute: \"numeric\",\n        hour12: true\n    };\n    const formattedDateTime = new Date(dateString).toLocaleString(\"en-US\", dateTimeOptions);\n    const formattedDateDay = new Date(dateString).toLocaleString(\"en-US\", dateDayOptions);\n    const formattedDate = new Date(dateString).toLocaleString(\"en-US\", dateOptions);\n    const formattedTime = new Date(dateString).toLocaleString(\"en-US\", timeOptions);\n    return {\n        dateTime: formattedDateTime,\n        dateDay: formattedDateDay,\n        dateOnly: formattedDate,\n        timeOnly: formattedTime\n    };\n};\nfunction formatAmount(amount) {\n    const formatter = new Intl.NumberFormat(\"en-US\", {\n        style: \"currency\",\n        currency: \"USD\",\n        minimumFractionDigits: 2\n    });\n    return formatter.format(amount);\n}\nconst parseStringify = (value)=>JSON.parse(JSON.stringify(value));\nconst removeSpecialCharacters = (value)=>{\n    return value.replace(/[^\\w\\s]/gi, \"\");\n};\nfunction formUrlQuery(param) {\n    let { params, key, value } = param;\n    const currentUrl = query_string__WEBPACK_IMPORTED_MODULE_3__[\"default\"].parse(params);\n    currentUrl[key] = value;\n    return query_string__WEBPACK_IMPORTED_MODULE_3__[\"default\"].stringifyUrl({\n        url: window.location.pathname,\n        query: currentUrl\n    }, {\n        skipNull: true\n    });\n}\nfunction getAccountTypeColors(type) {\n    switch(type){\n        case \"depository\":\n            return {\n                bg: \"bg-blue-25\",\n                lightBg: \"bg-blue-100\",\n                title: \"text-blue-900\",\n                subText: \"text-blue-700\"\n            };\n        case \"credit\":\n            return {\n                bg: \"bg-success-25\",\n                lightBg: \"bg-success-100\",\n                title: \"text-success-900\",\n                subText: \"text-success-700\"\n            };\n        default:\n            return {\n                bg: \"bg-green-25\",\n                lightBg: \"bg-green-100\",\n                title: \"text-green-900\",\n                subText: \"text-green-700\"\n            };\n    }\n}\nfunction countTransactionCategories(transactions) {\n    const categoryCounts = {};\n    let totalCount = 0;\n    // Iterate over each transaction\n    transactions && transactions.forEach((transaction)=>{\n        // Extract the category from the transaction\n        const category = transaction.category;\n        // If the category exists in the categoryCounts object, increment its count\n        if (categoryCounts.hasOwnProperty(category)) {\n            categoryCounts[category]++;\n        } else {\n            // Otherwise, initialize the count to 1\n            categoryCounts[category] = 1;\n        }\n        // Increment total count\n        totalCount++;\n    });\n    // Convert the categoryCounts object to an array of objects\n    const aggregatedCategories = Object.keys(categoryCounts).map((category)=>({\n            name: category,\n            count: categoryCounts[category],\n            totalCount\n        }));\n    // Sort the aggregatedCategories array by count in descending order\n    aggregatedCategories.sort((a, b)=>b.count - a.count);\n    return aggregatedCategories;\n}\nfunction extractCustomerIdFromUrl(url) {\n    // Split the URL string by '/'\n    const parts = url.split(\"/\");\n    // Extract the last part, which represents the customer ID\n    const customerId = parts[parts.length - 1];\n    return customerId;\n}\nfunction encryptId(id) {\n    return btoa(id);\n}\nfunction decryptId(id) {\n    return atob(id);\n}\nconst getTransactionStatus = (date)=>{\n    const today = new Date();\n    const twoDaysAgo = new Date(today);\n    twoDaysAgo.setDate(today.getDate() - 2);\n    return date > twoDaysAgo ? \"Processing\" : \"Success\";\n};\nconst authFormSchema = (type)=>zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n        email: zod__WEBPACK_IMPORTED_MODULE_4__.z.string().email(),\n        password: zod__WEBPACK_IMPORTED_MODULE_4__.z.string().min(5),\n        firstName: type === \"SignIn\" ? zod__WEBPACK_IMPORTED_MODULE_4__.z.string().optional() : zod__WEBPACK_IMPORTED_MODULE_4__.z.string().min(5),\n        lastName: type === \"SignIn\" ? zod__WEBPACK_IMPORTED_MODULE_4__.z.string().optional() : zod__WEBPACK_IMPORTED_MODULE_4__.z.string().min(5)\n    });\nconst formatDateToDisplay = (dateString)=>{\n    const date = new Date(dateString);\n    const options = {\n        day: \"2-digit\",\n        month: \"short\",\n        year: \"numeric\"\n    };\n    return date.toLocaleDateString(\"en-GB\", options).replace(\",\", \"\").replace(/(\\d{2}) (\\w{3}) (\\d{4})/, \"$1-$2-$3\");\n};\nconst calculateInterest = (formData)=>{\n    const { amount, startDate, endDate, rate } = formData;\n    // Calculate Time\n    const a = moment__WEBPACK_IMPORTED_MODULE_1___default()(endDate);\n    const b = moment__WEBPACK_IMPORTED_MODULE_1___default()(startDate);\n    let years = a.diff(b, \"year\");\n    b.add(years, \"years\");\n    let months = a.diff(b, \"months\");\n    b.add(months, \"months\");\n    let days = a.diff(b, \"days\");\n    // Calculate Interest\n    let interTable = \"\";\n    let tempAmount = amount;\n    let totalInter = 0;\n    // Calculate interest for years\n    for(let i = 0; i < years; i++){\n        const inter = tempAmount / 100 * rate;\n        totalInter += inter;\n        tempAmount += inter;\n        interTable += \"\".concat(i + 1, \" Year: \").concat(inter.toFixed(2), \" and Amount: \").concat(tempAmount.toFixed(2), \"\\n\");\n    }\n    // Calculate interest for months\n    const monRate = rate / 12;\n    for(let i = 0; i < months; i++){\n        const inter = tempAmount / 100 * monRate;\n        totalInter += inter;\n        interTable += \"\".concat(years, \" Year and \").concat(i + 1, \" Month: \").concat(inter.toFixed(2), \" and Amount: \").concat(tempAmount.toFixed(2), \"\\n\");\n    }\n    // Calculate interest for days\n    const dateRate = (rate / 12 / moment__WEBPACK_IMPORTED_MODULE_1___default()(endDate).daysInMonth()).toFixed(2);\n    for(let i = 0; i < days; i++){\n        const inter = tempAmount / 100 * parseFloat(dateRate);\n        totalInter += inter;\n    }\n    interTable += \"\".concat(years, \" Year and \").concat(months, \" Month and \").concat(days, \" Day: \").concat(totalInter.toFixed(2), \" and Amount: \").concat(tempAmount.toFixed(2), \"\\n\");\n    return {\n        interTable,\n        totalInterest: totalInter,\n        totalAmount: tempAmount,\n        time: \"\".concat(years, \" years \").concat(months, \" months \").concat(days, \" days\")\n    };\n};\nconst convertNumberToMoney = (money)=>{\n    var moneyvalue = money || 0;\n    const returnMoney = moneyvalue.toLocaleString(\"en-IN\", {\n        maximumFractionDigits: 0,\n        style: \"currency\",\n        currency: \"INR\"\n    });\n    return returnMoney;\n};\nconst fetchMetalsPrices = async ()=>{\n    const API_KEY = process.env.APISED_API_KEY;\n    let BASE_URL = process.env.APISED_API_KEY_URL || \"\";\n    try {\n        const response = await axios__WEBPACK_IMPORTED_MODULE_5__[\"default\"].get(BASE_URL, {\n            params: {\n                metals: \"XAU,XAG\",\n                base_currency: \"INR\",\n                currencies: \"INR\",\n                weight_unit: \"gram\"\n            },\n            headers: {\n                \"x-api-key\": API_KEY\n            }\n        });\n        const { data } = response.data; // Update based on the actual API response structure\n        const timestamp = data.timestamp;\n        const goldPrice = data.metal_prices.XAU.price;\n        const silverPrice = data.metal_prices.XAG.price;\n        return {\n            goldPrice,\n            silverPrice,\n            timestamp\n        };\n    } catch (error) {\n        console.error(\"Error fetching metals prices:\", error);\n        throw new Error(\"Failed to fetch data from APISed API\");\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LElBQUlDLGFBQWFELFNBQVM7SUFDMUIsTUFBTUUsY0FBYyxXQUFhaEgsY0FBYyxDQUFDLFNBQVU7UUFDbERpSCx1QkFBdUI7UUFBRXBHLE9BQU87UUFDaENDLFVBQVU7SUFDWjtJQUNOLE9BQU9rRztBQUNULEVBQUM7QUFTTSxNQUFNRSxvQkFBb0I7SUFFL0IsTUFBTUMsVUFBVUMsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxjQUFjO0lBQzFDLElBQUlDLFdBQVdILE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0csa0JBQWtCLElBQUk7SUFFakQsSUFBSTtRQUVGLE1BQU1DLFdBQVcsTUFBTTNJLDZDQUFLQSxDQUFDNEksR0FBRyxDQUFDSCxVQUFVO1lBQ3pDOUYsUUFBUTtnQkFDTmtHLFFBQVE7Z0JBQ1JDLGVBQWU7Z0JBQ2ZDLFlBQVk7Z0JBQ1pDLGFBQWE7WUFDZjtZQUNBQyxTQUFTO2dCQUNQLGFBQWFaO1lBQ2Y7UUFDRjtRQUVBLE1BQU0sRUFBRWEsSUFBSSxFQUFFLEdBQUdQLFNBQVNPLElBQUksRUFBRyxvREFBb0Q7UUFFckYsTUFBTUMsWUFBWUQsS0FBS0MsU0FBUztRQUVoQyxNQUFNQyxZQUFZRixLQUFLRyxZQUFZLENBQUNDLEdBQUcsQ0FBQ0MsS0FBSztRQUM3QyxNQUFNQyxjQUFjTixLQUFLRyxZQUFZLENBQUNJLEdBQUcsQ0FBQ0YsS0FBSztRQUUvQyxPQUFPO1lBQUVIO1lBQVdJO1lBQWFMO1FBQVU7SUFFN0MsRUFBRSxPQUFPTyxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyxpQ0FBaUNBO1FBQy9DLE1BQU0sSUFBSUUsTUFBTTtJQUNsQjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3V0aWxzLnRzP2Y3NDUiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zICovXG5pbXBvcnQgeyB0eXBlIENsYXNzVmFsdWUsIGNsc3ggfSBmcm9tIFwiY2xzeFwiO1xuaW1wb3J0IHFzIGZyb20gXCJxdWVyeS1zdHJpbmdcIjtcbmltcG9ydCB7IHR3TWVyZ2UgfSBmcm9tIFwidGFpbHdpbmQtbWVyZ2VcIjtcbmltcG9ydCB7IHogfSBmcm9tIFwiem9kXCI7XG5pbXBvcnQgbW9tZW50IGZyb20gJ21vbWVudCc7XG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuXG5leHBvcnQgZnVuY3Rpb24gY24oLi4uaW5wdXRzOiBDbGFzc1ZhbHVlW10pIHtcbiAgcmV0dXJuIHR3TWVyZ2UoY2xzeChpbnB1dHMpKTtcbn1cblxuLy8gRk9STUFUIERBVEUgVElNRVxuZXhwb3J0IGNvbnN0IGZvcm1hdERhdGVUaW1lID0gKGRhdGVTdHJpbmc6IERhdGUpID0+IHtcbiAgY29uc3QgZGF0ZVRpbWVPcHRpb25zOiBJbnRsLkRhdGVUaW1lRm9ybWF0T3B0aW9ucyA9IHtcbiAgICB3ZWVrZGF5OiBcInNob3J0XCIsIC8vIGFiYnJldmlhdGVkIHdlZWtkYXkgbmFtZSAoZS5nLiwgJ01vbicpXG4gICAgbW9udGg6IFwic2hvcnRcIiwgLy8gYWJicmV2aWF0ZWQgbW9udGggbmFtZSAoZS5nLiwgJ09jdCcpXG4gICAgZGF5OiBcIm51bWVyaWNcIiwgLy8gbnVtZXJpYyBkYXkgb2YgdGhlIG1vbnRoIChlLmcuLCAnMjUnKVxuICAgIGhvdXI6IFwibnVtZXJpY1wiLCAvLyBudW1lcmljIGhvdXIgKGUuZy4sICc4JylcbiAgICBtaW51dGU6IFwibnVtZXJpY1wiLCAvLyBudW1lcmljIG1pbnV0ZSAoZS5nLiwgJzMwJylcbiAgICBob3VyMTI6IHRydWUsIC8vIHVzZSAxMi1ob3VyIGNsb2NrICh0cnVlKSBvciAyNC1ob3VyIGNsb2NrIChmYWxzZSlcbiAgfTtcblxuICBjb25zdCBkYXRlRGF5T3B0aW9uczogSW50bC5EYXRlVGltZUZvcm1hdE9wdGlvbnMgPSB7XG4gICAgd2Vla2RheTogXCJzaG9ydFwiLCAvLyBhYmJyZXZpYXRlZCB3ZWVrZGF5IG5hbWUgKGUuZy4sICdNb24nKVxuICAgIHllYXI6IFwibnVtZXJpY1wiLCAvLyBudW1lcmljIHllYXIgKGUuZy4sICcyMDIzJylcbiAgICBtb250aDogXCIyLWRpZ2l0XCIsIC8vIGFiYnJldmlhdGVkIG1vbnRoIG5hbWUgKGUuZy4sICdPY3QnKVxuICAgIGRheTogXCIyLWRpZ2l0XCIsIC8vIG51bWVyaWMgZGF5IG9mIHRoZSBtb250aCAoZS5nLiwgJzI1JylcbiAgfTtcblxuICBjb25zdCBkYXRlT3B0aW9uczogSW50bC5EYXRlVGltZUZvcm1hdE9wdGlvbnMgPSB7XG4gICAgbW9udGg6IFwic2hvcnRcIiwgLy8gYWJicmV2aWF0ZWQgbW9udGggbmFtZSAoZS5nLiwgJ09jdCcpXG4gICAgeWVhcjogXCJudW1lcmljXCIsIC8vIG51bWVyaWMgeWVhciAoZS5nLiwgJzIwMjMnKVxuICAgIGRheTogXCJudW1lcmljXCIsIC8vIG51bWVyaWMgZGF5IG9mIHRoZSBtb250aCAoZS5nLiwgJzI1JylcbiAgfTtcblxuICBjb25zdCB0aW1lT3B0aW9uczogSW50bC5EYXRlVGltZUZvcm1hdE9wdGlvbnMgPSB7XG4gICAgaG91cjogXCJudW1lcmljXCIsIC8vIG51bWVyaWMgaG91ciAoZS5nLiwgJzgnKVxuICAgIG1pbnV0ZTogXCJudW1lcmljXCIsIC8vIG51bWVyaWMgbWludXRlIChlLmcuLCAnMzAnKVxuICAgIGhvdXIxMjogdHJ1ZSwgLy8gdXNlIDEyLWhvdXIgY2xvY2sgKHRydWUpIG9yIDI0LWhvdXIgY2xvY2sgKGZhbHNlKVxuICB9O1xuXG4gIGNvbnN0IGZvcm1hdHRlZERhdGVUaW1lOiBzdHJpbmcgPSBuZXcgRGF0ZShkYXRlU3RyaW5nKS50b0xvY2FsZVN0cmluZyhcbiAgICBcImVuLVVTXCIsXG4gICAgZGF0ZVRpbWVPcHRpb25zXG4gICk7XG5cbiAgY29uc3QgZm9ybWF0dGVkRGF0ZURheTogc3RyaW5nID0gbmV3IERhdGUoZGF0ZVN0cmluZykudG9Mb2NhbGVTdHJpbmcoXG4gICAgXCJlbi1VU1wiLFxuICAgIGRhdGVEYXlPcHRpb25zXG4gICk7XG5cbiAgY29uc3QgZm9ybWF0dGVkRGF0ZTogc3RyaW5nID0gbmV3IERhdGUoZGF0ZVN0cmluZykudG9Mb2NhbGVTdHJpbmcoXG4gICAgXCJlbi1VU1wiLFxuICAgIGRhdGVPcHRpb25zXG4gICk7XG5cbiAgY29uc3QgZm9ybWF0dGVkVGltZTogc3RyaW5nID0gbmV3IERhdGUoZGF0ZVN0cmluZykudG9Mb2NhbGVTdHJpbmcoXG4gICAgXCJlbi1VU1wiLFxuICAgIHRpbWVPcHRpb25zXG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICBkYXRlVGltZTogZm9ybWF0dGVkRGF0ZVRpbWUsXG4gICAgZGF0ZURheTogZm9ybWF0dGVkRGF0ZURheSxcbiAgICBkYXRlT25seTogZm9ybWF0dGVkRGF0ZSxcbiAgICB0aW1lT25seTogZm9ybWF0dGVkVGltZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRBbW91bnQoYW1vdW50OiBudW1iZXIpOiBzdHJpbmcge1xuICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQoXCJlbi1VU1wiLCB7XG4gICAgc3R5bGU6IFwiY3VycmVuY3lcIixcbiAgICBjdXJyZW5jeTogXCJVU0RcIixcbiAgICBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IDIsXG4gIH0pO1xuXG4gIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KGFtb3VudCk7XG59XG5cbmV4cG9ydCBjb25zdCBwYXJzZVN0cmluZ2lmeSA9ICh2YWx1ZTogYW55KSA9PiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG5cbmV4cG9ydCBjb25zdCByZW1vdmVTcGVjaWFsQ2hhcmFjdGVycyA9ICh2YWx1ZTogc3RyaW5nKSA9PiB7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9bXlxcd1xcc10vZ2ksIFwiXCIpO1xufTtcblxuaW50ZXJmYWNlIFVybFF1ZXJ5UGFyYW1zIHtcbiAgcGFyYW1zOiBzdHJpbmc7XG4gIGtleTogc3RyaW5nO1xuICB2YWx1ZTogc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybVVybFF1ZXJ5KHsgcGFyYW1zLCBrZXksIHZhbHVlIH06IFVybFF1ZXJ5UGFyYW1zKSB7XG4gIGNvbnN0IGN1cnJlbnRVcmwgPSBxcy5wYXJzZShwYXJhbXMpO1xuXG4gIGN1cnJlbnRVcmxba2V5XSA9IHZhbHVlO1xuXG4gIHJldHVybiBxcy5zdHJpbmdpZnlVcmwoXG4gICAge1xuICAgICAgdXJsOiB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICBxdWVyeTogY3VycmVudFVybCxcbiAgICB9LFxuICAgIHsgc2tpcE51bGw6IHRydWUgfVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWNjb3VudFR5cGVDb2xvcnModHlwZTogQWNjb3VudFR5cGVzKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgXCJkZXBvc2l0b3J5XCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiZzogXCJiZy1ibHVlLTI1XCIsXG4gICAgICAgIGxpZ2h0Qmc6IFwiYmctYmx1ZS0xMDBcIixcbiAgICAgICAgdGl0bGU6IFwidGV4dC1ibHVlLTkwMFwiLFxuICAgICAgICBzdWJUZXh0OiBcInRleHQtYmx1ZS03MDBcIixcbiAgICAgIH07XG5cbiAgICBjYXNlIFwiY3JlZGl0XCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiZzogXCJiZy1zdWNjZXNzLTI1XCIsXG4gICAgICAgIGxpZ2h0Qmc6IFwiYmctc3VjY2Vzcy0xMDBcIixcbiAgICAgICAgdGl0bGU6IFwidGV4dC1zdWNjZXNzLTkwMFwiLFxuICAgICAgICBzdWJUZXh0OiBcInRleHQtc3VjY2Vzcy03MDBcIixcbiAgICAgIH07XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmc6IFwiYmctZ3JlZW4tMjVcIixcbiAgICAgICAgbGlnaHRCZzogXCJiZy1ncmVlbi0xMDBcIixcbiAgICAgICAgdGl0bGU6IFwidGV4dC1ncmVlbi05MDBcIixcbiAgICAgICAgc3ViVGV4dDogXCJ0ZXh0LWdyZWVuLTcwMFwiLFxuICAgICAgfTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY291bnRUcmFuc2FjdGlvbkNhdGVnb3JpZXMoXG4gIHRyYW5zYWN0aW9uczogVHJhbnNhY3Rpb25bXVxuKTogQ2F0ZWdvcnlDb3VudFtdIHtcbiAgY29uc3QgY2F0ZWdvcnlDb3VudHM6IHsgW2NhdGVnb3J5OiBzdHJpbmddOiBudW1iZXIgfSA9IHt9O1xuICBsZXQgdG90YWxDb3VudCA9IDA7XG5cbiAgLy8gSXRlcmF0ZSBvdmVyIGVhY2ggdHJhbnNhY3Rpb25cbiAgdHJhbnNhY3Rpb25zICYmXG4gICAgdHJhbnNhY3Rpb25zLmZvckVhY2goKHRyYW5zYWN0aW9uKSA9PiB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBjYXRlZ29yeSBmcm9tIHRoZSB0cmFuc2FjdGlvblxuICAgICAgY29uc3QgY2F0ZWdvcnkgPSB0cmFuc2FjdGlvbi5jYXRlZ29yeTtcblxuICAgICAgLy8gSWYgdGhlIGNhdGVnb3J5IGV4aXN0cyBpbiB0aGUgY2F0ZWdvcnlDb3VudHMgb2JqZWN0LCBpbmNyZW1lbnQgaXRzIGNvdW50XG4gICAgICBpZiAoY2F0ZWdvcnlDb3VudHMuaGFzT3duUHJvcGVydHkoY2F0ZWdvcnkpKSB7XG4gICAgICAgIGNhdGVnb3J5Q291bnRzW2NhdGVnb3J5XSsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBpbml0aWFsaXplIHRoZSBjb3VudCB0byAxXG4gICAgICAgIGNhdGVnb3J5Q291bnRzW2NhdGVnb3J5XSA9IDE7XG4gICAgICB9XG5cbiAgICAgIC8vIEluY3JlbWVudCB0b3RhbCBjb3VudFxuICAgICAgdG90YWxDb3VudCsrO1xuICAgIH0pO1xuXG4gIC8vIENvbnZlcnQgdGhlIGNhdGVnb3J5Q291bnRzIG9iamVjdCB0byBhbiBhcnJheSBvZiBvYmplY3RzXG4gIGNvbnN0IGFnZ3JlZ2F0ZWRDYXRlZ29yaWVzOiBDYXRlZ29yeUNvdW50W10gPSBPYmplY3Qua2V5cyhjYXRlZ29yeUNvdW50cykubWFwKFxuICAgIChjYXRlZ29yeSkgPT4gKHtcbiAgICAgIG5hbWU6IGNhdGVnb3J5LFxuICAgICAgY291bnQ6IGNhdGVnb3J5Q291bnRzW2NhdGVnb3J5XSxcbiAgICAgIHRvdGFsQ291bnQsXG4gICAgfSlcbiAgKTtcblxuICAvLyBTb3J0IHRoZSBhZ2dyZWdhdGVkQ2F0ZWdvcmllcyBhcnJheSBieSBjb3VudCBpbiBkZXNjZW5kaW5nIG9yZGVyXG4gIGFnZ3JlZ2F0ZWRDYXRlZ29yaWVzLnNvcnQoKGEsIGIpID0+IGIuY291bnQgLSBhLmNvdW50KTtcblxuICByZXR1cm4gYWdncmVnYXRlZENhdGVnb3JpZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0Q3VzdG9tZXJJZEZyb21VcmwodXJsOiBzdHJpbmcpIHtcbiAgLy8gU3BsaXQgdGhlIFVSTCBzdHJpbmcgYnkgJy8nXG4gIGNvbnN0IHBhcnRzID0gdXJsLnNwbGl0KFwiL1wiKTtcblxuICAvLyBFeHRyYWN0IHRoZSBsYXN0IHBhcnQsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGN1c3RvbWVyIElEXG4gIGNvbnN0IGN1c3RvbWVySWQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcblxuICByZXR1cm4gY3VzdG9tZXJJZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuY3J5cHRJZChpZDogc3RyaW5nKSB7XG4gIHJldHVybiBidG9hKGlkKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlY3J5cHRJZChpZDogc3RyaW5nKSB7XG4gIHJldHVybiBhdG9iKGlkKTtcbn1cblxuZXhwb3J0IGNvbnN0IGdldFRyYW5zYWN0aW9uU3RhdHVzID0gKGRhdGU6IERhdGUpID0+IHtcbiAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICBjb25zdCB0d29EYXlzQWdvID0gbmV3IERhdGUodG9kYXkpO1xuICB0d29EYXlzQWdvLnNldERhdGUodG9kYXkuZ2V0RGF0ZSgpIC0gMik7XG5cbiAgcmV0dXJuIGRhdGUgPiB0d29EYXlzQWdvID8gXCJQcm9jZXNzaW5nXCIgOiBcIlN1Y2Nlc3NcIjtcbn07XG5cbmV4cG9ydCBjb25zdCBhdXRoRm9ybVNjaGVtYSA9ICh0eXBlOnN0cmluZykgPT4gei5vYmplY3Qoe1xuICBlbWFpbCA6ei5zdHJpbmcoKS5lbWFpbCgpLFxuICBwYXNzd29yZCA6ei5zdHJpbmcoKS5taW4oNSksXG4gIGZpcnN0TmFtZSA6IHR5cGUgPT09J1NpZ25Jbic/IHouc3RyaW5nKCkub3B0aW9uYWwoKSA6IHouc3RyaW5nKCkubWluKDUpLFxuICBsYXN0TmFtZSA6IHR5cGUgPT09J1NpZ25Jbic/IHouc3RyaW5nKCkub3B0aW9uYWwoKSA6IHouc3RyaW5nKCkubWluKDUpLFxufSlcblxuXG5leHBvcnQgY29uc3QgZm9ybWF0RGF0ZVRvRGlzcGxheSA9IChkYXRlU3RyaW5nIDogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShkYXRlU3RyaW5nKTtcbiAgXG4gIGNvbnN0IG9wdGlvbnMgOmFueSA9IHtcbiAgICBkYXk6ICcyLWRpZ2l0JyxcbiAgICBtb250aDogJ3Nob3J0JyxcbiAgICB5ZWFyOiAnbnVtZXJpYydcbiAgfTtcbiAgXG4gIHJldHVybiBkYXRlLnRvTG9jYWxlRGF0ZVN0cmluZygnZW4tR0InLCBvcHRpb25zKS5yZXBsYWNlKCcsJywgJycpLnJlcGxhY2UoLyhcXGR7Mn0pIChcXHd7M30pIChcXGR7NH0pLywgJyQxLSQyLSQzJyk7XG59XG5leHBvcnQgY29uc3QgY2FsY3VsYXRlSW50ZXJlc3QgPSAoZm9ybURhdGEgOiBhbnkpID0+IHtcblxuICBjb25zdCB7IGFtb3VudCwgc3RhcnREYXRlLCBlbmREYXRlLCByYXRlIH0gPSBmb3JtRGF0YTtcblxuICAvLyBDYWxjdWxhdGUgVGltZVxuICBjb25zdCBhID0gbW9tZW50KGVuZERhdGUpO1xuICBjb25zdCBiID0gbW9tZW50KHN0YXJ0RGF0ZSk7XG5cblxuICBsZXQgeWVhcnMgPSBhLmRpZmYoYiwgJ3llYXInKTtcbiAgYi5hZGQoeWVhcnMsICd5ZWFycycpO1xuICBsZXQgbW9udGhzID0gYS5kaWZmKGIsICdtb250aHMnKTtcbiAgYi5hZGQobW9udGhzLCAnbW9udGhzJyk7XG4gIGxldCBkYXlzID0gYS5kaWZmKGIsICdkYXlzJyk7XG5cbiAgLy8gQ2FsY3VsYXRlIEludGVyZXN0XG4gIGxldCBpbnRlclRhYmxlID0gXCJcIjtcbiAgbGV0IHRlbXBBbW91bnQgPSBhbW91bnQ7XG4gIGxldCB0b3RhbEludGVyID0gMDtcblxuICAvLyBDYWxjdWxhdGUgaW50ZXJlc3QgZm9yIHllYXJzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgeWVhcnM7IGkrKykge1xuICAgIGNvbnN0IGludGVyID0gKHRlbXBBbW91bnQgLyAxMDApICogcmF0ZTtcbiAgICB0b3RhbEludGVyICs9IGludGVyO1xuICAgIHRlbXBBbW91bnQgKz0gaW50ZXI7XG4gICAgaW50ZXJUYWJsZSArPSBgJHtpICsgMX0gWWVhcjogJHtpbnRlci50b0ZpeGVkKDIpfSBhbmQgQW1vdW50OiAke3RlbXBBbW91bnQudG9GaXhlZCgyKX1cXG5gO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIGludGVyZXN0IGZvciBtb250aHNcbiAgY29uc3QgbW9uUmF0ZSA9IHJhdGUgLyAxMjtcbiAgXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbW9udGhzOyBpKyspIHtcbiAgICBjb25zdCBpbnRlciA9ICh0ZW1wQW1vdW50IC8gMTAwKSAqIG1vblJhdGU7XG4gICAgdG90YWxJbnRlciArPSBpbnRlcjtcbiAgICBpbnRlclRhYmxlICs9IGAke3llYXJzfSBZZWFyIGFuZCAke2kgKyAxfSBNb250aDogJHtpbnRlci50b0ZpeGVkKDIpfSBhbmQgQW1vdW50OiAke3RlbXBBbW91bnQudG9GaXhlZCgyKX1cXG5gO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIGludGVyZXN0IGZvciBkYXlzXG4gIGNvbnN0IGRhdGVSYXRlID0gKChyYXRlIC8gMTIpIC8gbW9tZW50KGVuZERhdGUpLmRheXNJbk1vbnRoKCkpLnRvRml4ZWQoMik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF5czsgaSsrKSB7XG4gICAgY29uc3QgaW50ZXIgPSAodGVtcEFtb3VudCAvIDEwMCkgKiBwYXJzZUZsb2F0KGRhdGVSYXRlKTtcbiAgICB0b3RhbEludGVyICs9IGludGVyO1xuICB9XG5cbiAgaW50ZXJUYWJsZSArPSBgJHt5ZWFyc30gWWVhciBhbmQgJHttb250aHN9IE1vbnRoIGFuZCAke2RheXN9IERheTogJHt0b3RhbEludGVyLnRvRml4ZWQoMil9IGFuZCBBbW91bnQ6ICR7dGVtcEFtb3VudC50b0ZpeGVkKDIpfVxcbmA7XG5cblxuICByZXR1cm4ge1xuICAgIGludGVyVGFibGUsXG4gICAgdG90YWxJbnRlcmVzdDogdG90YWxJbnRlcixcbiAgICB0b3RhbEFtb3VudDogdGVtcEFtb3VudCxcbiAgICB0aW1lOiBgJHt5ZWFyc30geWVhcnMgJHttb250aHN9IG1vbnRocyAke2RheXN9IGRheXNgLFxuICB9O1xuXG59XG5cbmV4cG9ydCBjb25zdCBjb252ZXJ0TnVtYmVyVG9Nb25leSA9IChtb25leT86TnVtYmVyKSA9PntcbiAgdmFyIG1vbmV5dmFsdWUgPSBtb25leSB8fCAwXG4gIGNvbnN0IHJldHVybk1vbmV5ID0gKG1vbmV5dmFsdWUpLnRvTG9jYWxlU3RyaW5nKCdlbi1JTicsICB7XG4gICAgICAgICAgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiAwLHN0eWxlOiAnY3VycmVuY3knLFxuICAgICAgICAgIGN1cnJlbmN5OiAnSU5SJyxcbiAgICAgICAgfSk7XG4gIHJldHVybiByZXR1cm5Nb25leTtcbn1cblxuXG5pbnRlcmZhY2UgTWV0YWxzUHJpY2VzIHtcbiAgZ29sZFByaWNlOiBudW1iZXI7XG4gIHNpbHZlclByaWNlOiBudW1iZXI7XG4gIHRpbWVzdGFtcDogc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3QgZmV0Y2hNZXRhbHNQcmljZXMgPSBhc3luYyAoKTogUHJvbWlzZTxNZXRhbHNQcmljZXM+ID0+IHtcblxuICBjb25zdCBBUElfS0VZID0gcHJvY2Vzcy5lbnYuQVBJU0VEX0FQSV9LRVk7IFxuICBsZXQgQkFTRV9VUkwgPSBwcm9jZXNzLmVudi5BUElTRURfQVBJX0tFWV9VUkwgfHwgJyc7IFxuXG4gIHRyeSB7XG4gICAgXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoQkFTRV9VUkwsIHtcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBtZXRhbHM6ICdYQVUsWEFHJywgIC8vIEZldGNoIGdvbGQgLVhBVSwgc2lsdmVyIC0gWEFHXG4gICAgICAgIGJhc2VfY3VycmVuY3k6ICdJTlInLCAgXG4gICAgICAgIGN1cnJlbmNpZXM6ICdJTlInLFxuICAgICAgICB3ZWlnaHRfdW5pdDogJ2dyYW0nLCAgXG4gICAgICB9LFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAneC1hcGkta2V5JzogQVBJX0tFWSxcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHsgZGF0YSB9ID0gcmVzcG9uc2UuZGF0YTsgIC8vIFVwZGF0ZSBiYXNlZCBvbiB0aGUgYWN0dWFsIEFQSSByZXNwb25zZSBzdHJ1Y3R1cmVcbiBcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBkYXRhLnRpbWVzdGFtcDsgIFxuXG4gICAgY29uc3QgZ29sZFByaWNlID0gZGF0YS5tZXRhbF9wcmljZXMuWEFVLnByaWNlOyBcbiAgICBjb25zdCBzaWx2ZXJQcmljZSA9IGRhdGEubWV0YWxfcHJpY2VzLlhBRy5wcmljZTsgXG5cbiAgICByZXR1cm4geyBnb2xkUHJpY2UsIHNpbHZlclByaWNlLCB0aW1lc3RhbXAgfTsgIFxuXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgbWV0YWxzIHByaWNlczonLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggZGF0YSBmcm9tIEFQSVNlZCBBUEknKTtcbiAgfVxufTsiXSwibmFtZXMiOlsiY2xzeCIsInFzIiwidHdNZXJnZSIsInoiLCJtb21lbnQiLCJheGlvcyIsImNuIiwiaW5wdXRzIiwiZm9ybWF0RGF0ZVRpbWUiLCJkYXRlU3RyaW5nIiwiZGF0ZVRpbWVPcHRpb25zIiwid2Vla2RheSIsIm1vbnRoIiwiZGF5IiwiaG91ciIsIm1pbnV0ZSIsImhvdXIxMiIsImRhdGVEYXlPcHRpb25zIiwieWVhciIsImRhdGVPcHRpb25zIiwidGltZU9wdGlvbnMiLCJmb3JtYXR0ZWREYXRlVGltZSIsIkRhdGUiLCJ0b0xvY2FsZVN0cmluZyIsImZvcm1hdHRlZERhdGVEYXkiLCJmb3JtYXR0ZWREYXRlIiwiZm9ybWF0dGVkVGltZSIsImRhdGVUaW1lIiwiZGF0ZURheSIsImRhdGVPbmx5IiwidGltZU9ubHkiLCJmb3JtYXRBbW91bnQiLCJhbW91bnQiLCJmb3JtYXR0ZXIiLCJJbnRsIiwiTnVtYmVyRm9ybWF0Iiwic3R5bGUiLCJjdXJyZW5jeSIsIm1pbmltdW1GcmFjdGlvbkRpZ2l0cyIsImZvcm1hdCIsInBhcnNlU3RyaW5naWZ5IiwidmFsdWUiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJyZW1vdmVTcGVjaWFsQ2hhcmFjdGVycyIsInJlcGxhY2UiLCJmb3JtVXJsUXVlcnkiLCJwYXJhbXMiLCJrZXkiLCJjdXJyZW50VXJsIiwic3RyaW5naWZ5VXJsIiwidXJsIiwid2luZG93IiwibG9jYXRpb24iLCJwYXRobmFtZSIsInF1ZXJ5Iiwic2tpcE51bGwiLCJnZXRBY2NvdW50VHlwZUNvbG9ycyIsInR5cGUiLCJiZyIsImxpZ2h0QmciLCJ0aXRsZSIsInN1YlRleHQiLCJjb3VudFRyYW5zYWN0aW9uQ2F0ZWdvcmllcyIsInRyYW5zYWN0aW9ucyIsImNhdGVnb3J5Q291bnRzIiwidG90YWxDb3VudCIsImZvckVhY2giLCJ0cmFuc2FjdGlvbiIsImNhdGVnb3J5IiwiaGFzT3duUHJvcGVydHkiLCJhZ2dyZWdhdGVkQ2F0ZWdvcmllcyIsIk9iamVjdCIsImtleXMiLCJtYXAiLCJuYW1lIiwiY291bnQiLCJzb3J0IiwiYSIsImIiLCJleHRyYWN0Q3VzdG9tZXJJZEZyb21VcmwiLCJwYXJ0cyIsInNwbGl0IiwiY3VzdG9tZXJJZCIsImxlbmd0aCIsImVuY3J5cHRJZCIsImlkIiwiYnRvYSIsImRlY3J5cHRJZCIsImF0b2IiLCJnZXRUcmFuc2FjdGlvblN0YXR1cyIsImRhdGUiLCJ0b2RheSIsInR3b0RheXNBZ28iLCJzZXREYXRlIiwiZ2V0RGF0ZSIsImF1dGhGb3JtU2NoZW1hIiwib2JqZWN0IiwiZW1haWwiLCJzdHJpbmciLCJwYXNzd29yZCIsIm1pbiIsImZpcnN0TmFtZSIsIm9wdGlvbmFsIiwibGFzdE5hbWUiLCJmb3JtYXREYXRlVG9EaXNwbGF5Iiwib3B0aW9ucyIsInRvTG9jYWxlRGF0ZVN0cmluZyIsImNhbGN1bGF0ZUludGVyZXN0IiwiZm9ybURhdGEiLCJzdGFydERhdGUiLCJlbmREYXRlIiwicmF0ZSIsInllYXJzIiwiZGlmZiIsImFkZCIsIm1vbnRocyIsImRheXMiLCJpbnRlclRhYmxlIiwidGVtcEFtb3VudCIsInRvdGFsSW50ZXIiLCJpIiwiaW50ZXIiLCJ0b0ZpeGVkIiwibW9uUmF0ZSIsImRhdGVSYXRlIiwiZGF5c0luTW9udGgiLCJwYXJzZUZsb2F0IiwidG90YWxJbnRlcmVzdCIsInRvdGFsQW1vdW50IiwidGltZSIsImNvbnZlcnROdW1iZXJUb01vbmV5IiwibW9uZXkiLCJtb25leXZhbHVlIiwicmV0dXJuTW9uZXkiLCJtYXhpbXVtRnJhY3Rpb25EaWdpdHMiLCJmZXRjaE1ldGFsc1ByaWNlcyIsIkFQSV9LRVkiLCJwcm9jZXNzIiwiZW52IiwiQVBJU0VEX0FQSV9LRVkiLCJCQVNFX1VSTCIsIkFQSVNFRF9BUElfS0VZX1VSTCIsInJlc3BvbnNlIiwiZ2V0IiwibWV0YWxzIiwiYmFzZV9jdXJyZW5jeSIsImN1cnJlbmNpZXMiLCJ3ZWlnaHRfdW5pdCIsImhlYWRlcnMiLCJkYXRhIiwidGltZXN0YW1wIiwiZ29sZFByaWNlIiwibWV0YWxfcHJpY2VzIiwiWEFVIiwicHJpY2UiLCJzaWx2ZXJQcmljZSIsIlhBRyIsImVycm9yIiwiY29uc29sZSIsIkVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/utils.ts\n"));

/***/ })

});